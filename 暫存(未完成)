#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>

#include "hw2.h"
#define ADOPT_FIFO "adopt.fifo"
#define ERR_EXIT(s) perror(s), exit(errno);
#define MAX_NODES 100
#define MAX_BUF_SIZE 1024
// somethings I recommend leaving here, but you may delete as you please
static char root[MAX_FRIEND_INFO_LEN] = "Not_Tako";     // root of tree
static char friend_info[MAX_FRIEND_INFO_LEN];   // current process info
static char friend_name[MAX_FRIEND_NAME_LEN];   // current process name
static int friend_value;    // current process value
FILE* read_fp = NULL;
void get_friend_name(const char *friend_info, char *friend_name);
int get_friend_value(const char *friend_info);
// Is Root of tree
static inline bool is_Not_Tako() {
    return (strcmp(friend_name, root) == 0);
}

typedef struct Node {
    char friend_info[MAX_FRIEND_INFO_LEN];
    int friend_value;
    struct Node *first_child;
    struct Node *next_sibling;
    pid_t pid;
    int pipe_parent_to_child[2];
    int pipe_child_to_parent[2];
} Node;
typedef struct Queue{
	Node *nodes[100];
	int front;
	int rear;
}Queue;

void init_queue(Queue *q){
	q -> front = 0;
	q -> rear = 0;
}
void enqueue(Queue *q, Node *node){
	q -> nodes[q->rear++] = node;
}
Node *dequeue(Queue *q)	{
	return q->nodes[q->front++];
}
int is_empty(Queue *q){
	return q->front == q->rear;
}

// a bunch of prints for you
void print_direct_meet(char *friend_name) {
    fprintf(stdout, "Not_Tako has met %s by himself\n", friend_name);
}

void print_indirect_meet(char *parent_friend_name, char *child_friend_name) {
    fprintf(stdout, "Not_Tako has met %s through %s\n", child_friend_name, parent_friend_name);
}

void print_fail_meet(char *parent_friend_name, char *child_friend_name) {
    fprintf(stdout, "Not_Tako does not know %s to meet %s\n", parent_friend_name, child_friend_name);
}

void print_fail_check(const char *parent_friend_name){
    fprintf(stdout, "Not_Tako has checked, he doesn't know %s\n", parent_friend_name);
}

void print_success_adopt(char *parent_friend_name, char *child_friend_name) {
    fprintf(stdout, "%s has adopted %s\n", parent_friend_name, child_friend_name);
}

void print_fail_adopt(char *parent_friend_name, char *child_friend_name) {
    fprintf(stdout, "%s is a descendant of %s\n", parent_friend_name, child_friend_name);
}

void print_compare_gtr(char *friend_name){
    fprintf(stdout, "Not_Tako is still friends with %s\n", friend_name);
}

void print_compare_leq(char *friend_name){
    fprintf(stdout, "%s is dead to Not_Tako\n", friend_name);
}

void print_final_graduate(){
    fprintf(stdout, "Congratulations! You've finished Not_Tako's annoying tasks!\n");
}

Node* create_node(const char *friend_name, int friend_value) {
    Node *new_node = (Node *)malloc(sizeof(Node));
    if (strcmp(friend_name, "Not_Tako") == 0) {
        snprintf(new_node->friend_info, MAX_FRIEND_INFO_LEN, "%s", friend_name);
    } else {
        snprintf(new_node->friend_info, MAX_FRIEND_INFO_LEN, "%s_%02d", friend_name, friend_value);
    }
    new_node->pid = -1;
    new_node->first_child = NULL;
    new_node->next_sibling = NULL;

    // 初始化管道文件描述符
    new_node->pipe_parent_to_child[0] = -1;
    new_node->pipe_parent_to_child[1] = -1;
    new_node->pipe_child_to_parent[0] = -1;
    new_node->pipe_child_to_parent[1] = -1;

    return new_node;
}

Node* find_node(Node *root, const char *target_name) {
    if (root == NULL) return NULL;

    // 提取節點的 friend_name 部分
    char current_name[MAX_FRIEND_NAME_LEN];
    get_friend_name(root->friend_info, current_name);

    // 僅根據 friend_name 進行匹配
    if (strcmp(current_name, target_name) == 0) return root;

    // 遞迴查找子節點
    Node *child_result = find_node(root->first_child, target_name);
    if (child_result != NULL) return child_result;

    // 遞迴查找兄弟節點
    return find_node(root->next_sibling, target_name);
}

void get_friend_name(const char *friend_info, char *friend_name) {
    char temp[MAX_FRIEND_INFO_LEN];
    strncpy(temp, friend_info, MAX_FRIEND_INFO_LEN);
    char *underscore_pos = strchr(temp, '_');
    if (underscore_pos != NULL) {
        *underscore_pos = '\0';
        strncpy(friend_name, temp, MAX_FRIEND_NAME_LEN - 1);
        friend_name[MAX_FRIEND_NAME_LEN - 1] = '\0';
    }
}
int get_friend_value(const char *friend_info) {
    char *underscore_pos = strchr(friend_info, '_');
    if (underscore_pos != NULL) {
        return atoi(underscore_pos + 1);
    }
    return -1;  // 如果格式不正確，返回 -1
}
void add_child(Node *parent, Node *child) {
    if (parent->first_child == NULL) {
        parent->first_child = child;
    } else {
        Node *sibling = parent->first_child;
        while (sibling->next_sibling != NULL) {
            sibling = sibling->next_sibling;
        }
        sibling->next_sibling = child;
    }
}

void print_tree(Node *node){
    if (node == NULL) return;

    Queue q;
    init_queue(&q);
    enqueue(&q, node);

    while (!is_empty(&q)) {
        int level_size = q.rear - q.front;

        for (int i = 0; i < level_size; i++) {
            Node *current = dequeue(&q);

            // 檢查是否為空指針，避免訪問已釋放記憶體
            if (current == NULL) continue;

            printf("%s", current->friend_info);
            if (i < level_size - 1) {
                printf(" ");
            }
            Node *child = current->first_child;
            while (child != NULL) {
                enqueue(&q, child);
                child = child->next_sibling;
            }
        }
        printf("\n");
    }
}

void meet(Node *root, char *parent_friend_name, const char *child_friend_info) {
    Node *parent_node = find_node(root, parent_friend_name);
    
    if (strcmp(parent_friend_name, "Not_Tako") == 0) {
        parent_node = root;
    } else {
        // 否則，尋找相應的父節點
        parent_node = find_node(root, parent_friend_name);
        if (parent_node == NULL) {
            // 找不到父節點時顯示錯誤
            char child_name[MAX_FRIEND_NAME_LEN];
            get_friend_name(child_friend_info, child_name);
            print_fail_meet(parent_friend_name, child_name);
            return;
        }
    }

    int pipe_parent_to_child[2], pipe_child_to_parent[2];
    char buffer[1024];

    // 創建兩個管道
    if (pipe(pipe_parent_to_child) == -1 || pipe(pipe_child_to_parent) == -1) {
        ERR_EXIT("pipe");
    }

    pid_t pid = fork();
    if (pid < 0) {
        ERR_EXIT("fork");
    } else if (pid == 0) {
        // 子進程代碼
        close(pipe_parent_to_child[1]); // 關閉父進程寫的端點
        close(pipe_child_to_parent[0]); // 關閉父進程讀的端點

        // 重定向子進程的標準輸入和標準輸出到管道
        dup2(pipe_parent_to_child[0], STDIN_FILENO);
        dup2(pipe_child_to_parent[1], STDOUT_FILENO);

        // 關閉重定向後的管道端點
        close(pipe_parent_to_child[0]);
        close(pipe_child_to_parent[1]);

        // 執行新的程序
        execlp("./friend", "friend", child_friend_info, (char *)NULL);
        ERR_EXIT("execlp");
    } else {
        // 父進程代碼
        close(pipe_parent_to_child[0]); // 關閉子進程讀的端點
        close(pipe_child_to_parent[1]); // 關閉子進程寫的端點

        // 寫入訊息到子進程
        write(pipe_parent_to_child[1], "Hello from parent\n", 18);

        // 讀取子進程的回應
        ssize_t n = read(pipe_child_to_parent[0], buffer, sizeof(buffer) - 1);
        if (n > 0) {
            buffer[n] = '\0';
            printf("Parent received: %s\n", buffer);
        }

        // 關閉管道並等待子進程結束
        close(pipe_parent_to_child[1]);
        close(pipe_child_to_parent[0]);
        waitpid(pid, NULL, 0);

	char child_name[MAX_FRIEND_NAME_LEN];
        int child_value = get_friend_value(child_friend_info);
        get_friend_name(child_friend_info, child_name);
        Node *child_node = create_node(child_name, child_value);
	if (child_node == NULL) {
            fprintf(stderr, "Failed to create child node\n");
            return; // 若無法建立子節點則直接返回
        }
        
        child_node->pid = pid;
        add_child(parent_node, child_node);


        if (strcmp(parent_friend_name, "Not_Tako") == 0) {
            print_direct_meet(child_name);
        } else {
            print_indirect_meet(parent_friend_name, child_name);
        }
    }
}
void check(Node *root, const char *parent_friend_name) {
    Node *parent_node;

    // 如果查詢的是根節點 Not_Tako，直接使用 root
    if (strcmp(parent_friend_name, "Not_Tako") == 0) {
        parent_node = root;
    } else {
        // 否則使用 find_node 查找
        parent_node = find_node(root, parent_friend_name);
        if (parent_node == NULL) {
            printf("Not_Tako has checked, he doesn't know %s\n", parent_friend_name);
            return;
        }
    }

    // 打印節點和子樹的資訊
    print_tree(parent_node);
}
void terminate_subtree(Node *node) {
    if (node == NULL) return;

    // 先遞迴釋放子節點和兄弟節點
    if (node->first_child != NULL) {
        terminate_subtree(node->first_child);
        node->first_child = NULL;  // 避免再次訪問已釋放的子節點
    }
    if (node->next_sibling != NULL) {
        terminate_subtree(node->next_sibling);
        node->next_sibling = NULL;  // 避免再次訪問已釋放的兄弟節點
    }

    // 關閉管道並清理節點的指標
    if (node->pipe_parent_to_child[0] != -1) close(node->pipe_parent_to_child[0]);
    if (node->pipe_parent_to_child[1] != -1) close(node->pipe_parent_to_child[1]);
    if (node->pipe_child_to_parent[0] != -1) close(node->pipe_child_to_parent[0]);
    if (node->pipe_child_to_parent[1] != -1) close(node->pipe_child_to_parent[1]);

    // 等待子進程終止，避免僵屍進程
    if (node->pid > 0) waitpid(node->pid, NULL, WNOHANG);

    // 釋放該節點並將指標設為 NULL
    free(node);
}

Node* find_parent(Node* root, Node* target_node) {
    if (root == NULL || target_node == NULL) return NULL;

    Node* child = root->first_child;
    while (child != NULL) {
        if (child == target_node) {
            return root;
        }
        Node* parent = find_parent(child, target_node);
        if (parent != NULL) {
            return parent;
        }
        child = child->next_sibling;
    }
    return NULL;
}

void remove_node_from_parent(Node* parent, Node* target_node) {
    if (parent == NULL || target_node == NULL) return;

    // If the first child is the target node
    if (parent->first_child == target_node) {
        parent->first_child = target_node->next_sibling;
        target_node->next_sibling = NULL;  // 清空指標以避免後續操作
        return;
    }

    // Traverse the sibling list to find and remove the target node
    Node* prev = parent->first_child;
    while (prev != NULL && prev->next_sibling != NULL) {
        if (prev->next_sibling == target_node) {
            prev->next_sibling = target_node->next_sibling;
            target_node->next_sibling = NULL;  // 清空指標以避免後續操作
            return;
        }
        prev = prev->next_sibling;
    }
}

void graduate(Node* root, const char* friend_name) {
    Node* target_node;

    if (strcmp(friend_name, "Not_Tako") == 0) {
        target_node = root;
    } else {
        target_node = find_node(root, friend_name);
        if (target_node == NULL) {
            print_fail_check(friend_name);
            return;
        }
    }

    check(root, friend_name);

    // 如果 friend_name 不是根，從父節點中移除它
    if (strcmp(friend_name, "Not_Tako") != 0) {
        Node* parent_node = find_parent(root, target_node);
        if (parent_node != NULL) {
            remove_node_from_parent(parent_node, target_node);
        }
    }

    // 終止並釋放子樹
    terminate_subtree(target_node);

    // 根節點的特殊處理
    if (strcmp(friend_name, "Not_Tako") == 0) {
        print_final_graduate();
        exit(0);
    }
}
int adoptable(Node* parent, Node* child){
	if(parent == NULL || child == NULL)return 0;
	Node* temp = parent;
	while(temp != 0){
		if(temp == child) return 0;
		temp = find_parent(temp,temp);
	}
	return 1;
}

void write_to_fifo(Node* node) {
    int fd = open(ADOPT_FIFO, O_WRONLY | O_CREAT, 0666);
    if (fd < 0) {
        perror("FIFO open write failed");
        exit(1);
    }

    if (node == NULL) {
        close(fd);
        return;
    }

    char buf[MAX_BUF_SIZE];
    sprintf(buf, "%s %d\n", node->friend_info, node->friend_value);
    write(fd, buf, strlen(buf));

    if (node->first_child) write_to_fifo(node->first_child);
    if (node->next_sibling) write_to_fifo(node->next_sibling);

    close(fd);  // 確保文件描述符已關閉
}

void read_from_fifo(Node* root, Node* parent_node, int parent_value) {
    int fd = open(ADOPT_FIFO, O_RDONLY);
    if (fd < 0) {
        perror("FIFO Read Failed");
        exit(1);
    }

    char buf[MAX_BUF_SIZE];
    while (read(fd, buf, sizeof(buf)) > 0) {
        char friend_name[MAX_FRIEND_INFO_LEN];
        int friend_value;
        sscanf(buf, "%s %d", friend_name, &friend_value);
        friend_value %= parent_value;

        Node* new_node = create_node(friend_name, friend_value);
        if (new_node == NULL) {
            perror("Node creation failed");
            close(fd);
            return;
        }
        
        add_child(parent_node, new_node);
    }
    close(fd);  // 確保文件描述符已關閉
}

void mod(Node *node, int parent_value){
	if(node == NULL)return;

	node -> friend_value %= parent_value;

	mod(node -> first_child, parent_value);
	mod(node -> next_sibling,parent_value);
}
void adopt(Node* root, const char* parent_name, const char* child_name){
	Node* parent_node = find_node(root,parent_name);
	Node* child_node = find_node(root,child_name);

	if(parent_node == NULL || child_node == NULL){
		printf("Parent or child node not found\n");
		return;
	}

	if(!adoptable(parent_node,child_node)){
		print_fail_adopt((char*)parent_name, (char*)child_name);
		return;
	}
	
	mkfifo(ADOPT_FIFO, 0666);
	write_to_fifo(child_node);
	
	char child_name_buf[MAX_FRIEND_NAME_LEN];
	get_friend_name(child_node->friend_info, child_name_buf);
	Node* original_parent = find_parent(root, find_node(root, child_name_buf));
	
	if(original_parent){
		remove_node_from_parent(original_parent, child_node);
	}

	terminate_subtree(child_node);

	read_from_fifo(root,parent_node, parent_node -> friend_value);

	unlink(ADOPT_FIFO);

	print_success_adopt((char*)parent_name, (char*)child_name);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: ./friend [friend_info]\n");
        return 0;
    }
    setvbuf(stdout, NULL, _IONBF, 0);

    strncpy(friend_info, argv[1], MAX_FRIEND_INFO_LEN);
    Node *root_node = NULL;

    if (strcmp(argv[1], root) == 0) {
        root_node = create_node("Not_Tako", 0);
        strncpy(friend_name, friend_info, MAX_FRIEND_NAME_LEN);
        friend_name[MAX_FRIEND_NAME_LEN - 1] = '\0';
        read_fp = stdin;
        friend_value = 100;
    }

    char command[100];
    while (fgets(command, sizeof(command), read_fp)) {
        command[strcspn(command, "\n")] = '\0';

        if (strncmp(command, "Meet", 4) == 0) {
            char *token = strtok(command, " ");
            token = strtok(NULL, " ");
            char parent_friend_name[MAX_FRIEND_NAME_LEN];
            if (token != NULL) {
                strncpy(parent_friend_name, token, MAX_FRIEND_NAME_LEN - 1);
                parent_friend_name[MAX_FRIEND_NAME_LEN - 1] = '\0';
            } else {
                fprintf(stderr, "Invalid Meet command format: %s\n", command);
                continue;
            }

            token = strtok(NULL, " ");
            char child_friend_info[MAX_FRIEND_INFO_LEN];
            if (token != NULL) {
                strncpy(child_friend_info, token, MAX_FRIEND_INFO_LEN - 1);
                child_friend_info[MAX_FRIEND_INFO_LEN - 1] = '\0';
            } else {
                fprintf(stderr, "Invalid Meet command format: %s\n", command);
                continue;
            }

            meet(root_node, parent_friend_name, child_friend_info);

        } else if (strncmp(command, "Check", 5) == 0) {
            char parent_friend_name[MAX_FRIEND_NAME_LEN];
            if (sscanf(command, "Check %s", parent_friend_name) == 1) {
                check(root_node, parent_friend_name);
            } else {
                fprintf(stderr, "Invalid Check command format: %s\n", command);
            }

        } else if (strncmp(command, "Graduate", 8) == 0) {
		char friend_name[MAX_FRIEND_NAME_LEN];
    		if (sscanf(command, "Graduate %s", friend_name) == 1) {
        		graduate(root_node, friend_name);  // 直接使用 graduate 函式進行操作
    		} else {
        		fprintf(stderr, "Invalid Graduate command format: %s\n", command);
    		} 
	}else if(strncmp(command, "Adopt",5)==0){
		char parent_friend_name[MAX_FRIEND_INFO_LEN];
		char child_friend_name[MAX_FRIEND_INFO_LEN];

		if(sscanf(command,"Adopt %s %s",parent_friend_name, child_friend_name)!=2){
			printf("Invalid command format for Adopt.\n");
			continue;
		}
		adopt(root_node,parent_friend_name,child_friend_name);
	}
    }

    // 在程式結束時釋放整個樹結構
    if (root_node != NULL) {
        terminate_subtree(root_node);
    }

    return 0;
}

